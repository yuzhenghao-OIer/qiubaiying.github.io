---
layout:     post
title:      【LGR-071】洛谷4月月赛 & MdOI Round 2 Div.2题解
subtitle:   
date:       2020-04-13
author:     虞正皓
header-img: img/post-bg-os-metro.jpg
catalog: false
tags:
    - 洛谷
    - 题解
---
# A. Car
考点：简单字符串。
## Subtask 1
根据题意，外地车每天都限行，直接输出 `1 1 1 1 1` 即可。
## Subtask 2
还是要先判断是否为外地车。若是则直接输出并退出程序。

若为本地车，则由于最后一位一定是数字，故尾号一定是最后一位。

观察发现，除了周五，周 的限行尾号就是 和 ，我们可以用这个性质用 $for$ 语句判断周一到
周四的限行情况。
## Subtask 3
我们现在没有解决的一个问题是尾号究竟出现在哪一位。

根据题意，我们可以定义一个变量，从最后一位开始从左数，直到碰到第一个数字为止。

# B. Mayuri
涉及知识点：贪心。

首先，我们分析输出 -1 的情况。

容易发现，当 $a$ = 10 并且 的第一个字符为 1 时显然无解，具体证明同样例二。

除此以外的情况都是有解的。故在接下来的讨论中排除无解的情况。

## Subtask 1:
由于 $n$ 是正整数，在字符串长度为 1 位的情况下，如果输入的串是 0 ，则 显然是最小的答案。

如果输入的串是 1 ，则显然直接输出 $a$ 是最小的，因为 $a$ 的最小倍数就是 $a$ 本身。

## Subtask 2:
对于 $n$ 为两位数的情况，我们可以选择直接打表，直接算出每种可能的对应最小解。

我们也可以采用枚举所有两位数逐个判断的方式。

当我们判断某一个数是否符合条件时，我们通过除以 10 的方式得到其第一位，并判断其是否整除 。

如果第一位符合条件，我们再直接判断其是否整除 $a$ 以判断前 2 位是否满足条件。

## Subtask 3:
与上面的做法相似，直接枚举所有 10000 位数。

不同的是对于每一个数我们要判断 10000 次。

我们通过除以 得到其第一位，通过除以 900000 得到其前两位构成的数，以此类推。

对于每个数，逐一判断。先分离其第一位判断是否满足条件，若满足则分离前两位，以此类推。
由于 位数一共只有 6 个，因此我们只需要经过不超过 900000 次枚举就可以找到符合条件的
数。

## Subtask 4:
要判断一个数是否是 的倍数只需要判断最后一位是否为 2 的倍数 。

所以我们可以考虑从高位开始往后添加数字。

如果某一位是 1 ，则我们需要添加的数字是 2 4 6 8 0 中的一个。本着最小的原则，我们选择 0 。

同理，如果某一位是 0 则我们选择添加一个 。

另外，如果字符串的第一位是 1 ，则我们需要进行特判。

## Subtask 5:
考虑延续上面的做法，从高位往后添加数字。

由于我们是在高位上添加的，因此我们只需保证我们添加的数字最小，就一定是最优的。

对于第一位，如果第一位的字符是 0 则我们添加 1 最优，否则第一位添加 $a$ 最优。

然后对于后面的每一位，设我们当前的数是 $n_1$，添加的数是 $j$，则得到的数是 10 × $n_1$ + $j$。

由于 $j$ 只有十种可能性，分别枚举尝试，选取最小的加到数的尾端。

另外，由于 $n$ 过大，无法直接记录，故每添加一个数后对 $a$取模，然后输出时以字符串的方式输出。

## C.Odyssey
涉及知识点：拓扑排序，动态规划，整除的性质，唯一分解定理

## Subtask 1：
**特殊限制：**
当 $k$=1 时，任何两个正整数都组成完美数对，所以只要统计有向无环图上的最长路径即可。
这是一个经典的问题，可以用拓扑排序完成，设 $dp(i)$ 表示以 $(i,j,w,l)$ 为终点的最长路径，那么对于
边 ，则有转移 $dp(i)$+$l$ -> $dp(j)$，最后所有 的最大值即是答案。

该算法时间复杂度为 $O(m)$。 

## Subtask 2：
**特殊限制：**
由于 $n,m$ 都极小，从每个点开始暴力搜索即可。

注意当 $k$=2 时，可以先算出 1...100 中间所有数的平方，给这些平方数打个标记，然后对
于两个数 ，如果 $x,y$ 打过标记，则$(x,y)$组成完美数对。

时间复杂度取决于搜索的具体实现方式。

后面就不是说了

# D.Resurrection

## 结论

### 1.1 显然的东西
观察到，生成的图 $G$ 是一棵树，且假如把原树和新树都看作以 $n$ 为根
的有根树，那么新树的任意节点的父节点都是它在原树中的祖先节点。
考虑断掉一个节点的父边时，它一定会和某个祖先节点连边。

### 1.2 不那么显然的东西
我们考虑什么样的树可能是生成的新树。
一个必要条件是，任意两个祖先-后代节点到父边的连线要么相离，要
么某一条包含另一条。也就是说，不存在 $u$，$v$，$u$ 在 $G$ 中的父节点是 $x$，$v$ 是 $y$，满足 $u$ 是 $v$ 的祖先，且 $y$ 是 $u$ 的祖先，且 $x$ 是 $y$ 的祖先。
我们考虑 $u$ 的父边被断开的时候，在那之前，$u$ 到 $x$ 之间的任何边都
不能被断开，否则 $u$ 到 $x$ 的连边将无法完成。又因为，$y$ 被包含在 $u$ 到 $x$
的路径中，$v$ 所在联通块最大点至少是 $x$，其到 $y$ 的连线不可能在这之前完
成。而在这之后，$v$ 和 $y$ 不再联通，不可能相互连边。


同时，这个条件是充分的。考虑这样构造方案：维护一个决策集合，一
开始只有根的子节点。每次取决策集合中编号最小的点，断开它在原树中到
父节点的边，然后将它在新树中的子节点加入决策集合。
这样构造的方案一定是合法的，考虑点 $u$ 到父节点的连边，这个点不
可能比它的目标父节点 $v$ 大，因为只有在 $v$ 到父节点的边被断开后 $u$ 才可
能加入决策集合。同时这个点也不可能比 $v$ 小，假如这个点比 $v$ 小，那么
一定有 $u$ - $v$ 中某一条边被断开了，又因为这些点的编号都比 $u$ 大，必须它们比 $u$ 先加入决策集合才能出现这种情况。然而，根据这个条件的必要性，
$v$ 一定是这些节点在 $G$ 中的祖先节点，也就是，这些节点都不早于 $u$ 加入
决策集合。矛盾。

### 做法

每个节点会向自己的某个祖先节点连边，并且两条连线不能交叉。我们
要计算这样的方案数。考虑 dp。我们记 $f_i$,j 表示考虑到节点 $i$，祖先中有 $j$
个可以向其连边的节点时，子树中连边的方案数。
考虑枚举点 $u$ 和从下往上数，第 $x$ 个节点连边。那么，这条连线会覆
盖掉 $x$ - 1 个可以连边的节点，然后对于子树中的所有节点，$u$ 都是一个可
以连边的节点。
可以写出转移：

前缀和优化即可得到 $O$($n^2$) 做法。