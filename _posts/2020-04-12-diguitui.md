---
layout:     post
title:      专题训练 | 递归与递推赛前指导 
subtitle:   
date:       2020-04-12 
author:     虞正皓
header-img: img/post-bg-os-metro.jpg
catalog: true 
tags:
    - 算法
---
# 前言

这是最难理解的部分，建议画出递归图来理解递归的过程。

# 推荐题目

- [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)
- [P1464 Function](https://www.luogu.com.cn/problem/P1464)
- [P5534 【XR-3】等差数列](https://www.luogu.com.cn/problem/P5534)
- [P1192 台阶问题](https://www.luogu.com.cn/problem/P1192)
- [P1025 数的划分](https://www.luogu.com.cn/problem/P1025)
- [P4994 终于结束的起点](https://www.luogu.com.cn/problem/P4994)

# 比赛须知

命题人：虞正皓、待定

比赛时间：待定

赛后讲评：见压缩包（暂未公布）

题目数量：4题

# 复习

## 递归

### 1.概念
递归函数即自调用函数，在函数内部直接的或者间接地调用自己。在求解某些具有随意性的复杂问题时经常使用递归，如要求编写一个函数，将输入的任意长度的字符串反向输出。普通做法是将字符串放入数组中然后将数组元素反向输出即可，然而这里的要求是输入是任意长度的，总不能开辟一个很大的空间保存字符串吧？这时候递归就起作用了。递归采用了分治的思想，将整体分割成部分，从最小的基本部分入手，逐一解决，其中部分通常和整体具有相同的结构，这样部分可以继续分割，直到最后分割成基本部分。

递归函数必须定义一个终止条件，即什么情况下终止递归，终止继续调用自己，如果没有终止条件，那么函数将一直调用自己，知道程序栈耗尽，这时候等于是写了一个$Bug$!

总结递归的特点：

（1） 使用递归时，一定要有明确的终止条件！

（2） 递归算法解题通常代码比较简洁，但不是很容易读懂。

（3） 递归的调用需要建立大量的函数的副本，尤其是函数的参数，每一层递归调用时参数都是单独的占据内存空间，他们的地址是不同的，因此递归会消耗大量的时间和内存。而非递归函数虽然效率高，但相对比较难编程。

（4） 递归函数分为调用和回退阶段，递归的回退顺序是它调用顺序的逆序。

### 2.实践
斐波那契数列当$n$>3时，第$n$个元素的值等于第$n$-1个元素和$n$-2个元素的和，当n不确定具体数值时，可以通过递归的方式实现

```cpp 
int Fib(int n) {
    if (n < 2)
        return 1;
 
    return Fib(n - 1) + Fib(n - 2);
}
void test_fib(int n) {
    int fib1[n], fib2[n];
    fib1[0] = 1;
    fib1[1] = 1;
    fib2[0] = 1;
    fib2[1] = 1;
    for (int i = 2; i < n; i++) {
        fib1[i] = Fib(i);
        fib2[i] = fib2[i - 1] + fib2[i - 2];
    }
    cout << "use func Fib() " << endl;
    for (int i = 0; i < n; i++) {
        cout << fib1[i] << ' ';
    }
    cout << endl;
    cout << "use for loop " << endl;
    for (int i = 0; i < n; i++) {
        cout << fib2[i] << ' ';
    }
    cout << endl;
}
```
最终由递归得到的斐波那契数列和由$for$循环得到的数列相同。

阶乘问题同样可以通过递归实现，代码为
```cpp
int Factorial(int n) {
    if (n == 1)
        return 1;
    return n * Factorial(n - 1);
}
```
当n=5时，函数的调用过程如下图所示

![GX0eMD.png](https://s1.ax1x.com/2020/04/13/GX0eMD.png)

## 递推

递推也是经常被使用的一种~~简单的~~算法。递推是一种用若干步可重复的简单运算来描述复杂问题的方法。

递推的特点在于，每一项都和他前面的若干项由一定的关联，这种关联一般可以通过递推关系式来表示，可以通过其前面若干项得出某项的数据。

对于递推问题的求解一般从初始的一个或若干个数据项出发，通过递推关系式逐步推进，从而得出想要的结果，这种求解问题的方法叫递推法。其中，初始的若干数据项称为边界。

我们来看这样一道题目： 
已知一对兔子，每个月可以生一对小兔子，小兔子出生后的第二个月会变成年兔子，会继续生小兔子。

- 第一个月，我们有 1 对小兔子。
- 第二个月，我们有 1 对成年的兔子。
- 第三个月，我们有 1 对成年的兔子，有 1 对小兔子，共 2 对。
- 第四个月，我们有 2 对成年的兔子，有 1 对小兔子，共 3 对。
- 第五个月，我们有 3 对成年的兔子，有 2 对小兔子，共 5 对。

现在我们希望知道第n个月，一共有多少只兔子。（兔子身体素质好，不会死掉。） 
有可能你已经发现规律了，但是我们还是要来分析一下。

设第 $i$ 个月的兔子数量为 $F_i$，第 $i$ 月的成年兔子数量为 $a_i$，第 $i$ 月的小兔子数量为 $b_i$，那么 $F_i$ = $a_i$ + $b_i$。

第 $i$ 月的成年兔子，由第 $i$-1 个月的小兔子长大与第 $i$-1 月的成年兔子得到，也就是说，第 $i$-1 个月兔子的总数量，$a_i$ = $a_{i-1}$ + $b_{i-1}$ = $F_{i-1}$。

第 $i$ 月的小兔子，是由第 $i$-1 个月的成年兔子生的，也就是第 $i$-2 个月的成年兔子和小兔子，也就是 $i$-2 个月兔子的总数量，$b_i$ = $a_{i-1}$ = $a_{i-2}$ + $b_{i-1}$ = $F_{i-1}$。 

这样，我们就找到了这个题目的递推关系式，如果用 $F_i$ 代表第 $i$ 个月兔子的总数量，那么递推关系式为：$F_i$ = $F_{i-1}$ + $F_{i-2}$。边界值，我们知道 $F_1$ = $F_2$ = 1。那么，我们就可以写出代码：

```cpp
f[1] = 1, f[2] = 1;

for(int i = 3;i <= n; ++i) {
    f[i] = f[i-1] + f[i-2];
}
```

